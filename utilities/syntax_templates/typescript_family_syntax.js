/**
 * Build the syntax definition for TypeScript as a host language
 * @param {HostSpec} hostSpec - Specification for the host language
 * @param {EmbeddedSpec[]} embeddedSpecs - Array of data about each
 * embedded language
 * @returns {json} - Json object containing a TextMate language
 * injection
 */
export function buildTypescriptFamilySyntax(hostSpec, embeddedSpecs) {
    // Build the patterns that match each embedded language, using
    // a preceeding inline comment
    // Example: /*cpp*/ `...``

    // This same code is used for JS, JSX, TS, and TSX files (since
    // they all use the same syntax definitions, with a simple
    // mechanical transformation for the language id and scope names)
    const langInfo = {
        'typescript': {
            'tag_suffix': 'ts',
            'syntax_url': 'https://github.com/microsoft/vscode/blob/main/extensions/typescript-basics/syntaxes/TypeScript.tmLanguage.json',
        },
        'javascript': {
            'tag_suffix': 'js',
            'syntax_url': 'https://github.com/microsoft/vscode/blob/main/extensions/javascript/syntaxes/JavaScript.tmLanguage.json',
        },
        'typescriptreact': {
            'tag_suffix': 'tsx',
            'syntax_url': 'https://github.com/microsoft/vscode/blob/main/extensions/typescript-basics/syntaxes/TypeScriptReact.tmLanguage.json',
        },
        'javascriptreact': {
            'tag_suffix': 'js.jsx',
            'syntax_url': 'https://github.com/microsoft/vscode/blob/main/extensions/javascript/syntaxes/JavaScriptReact.tmLanguage.json',
        },
    };

    const suffix=langInfo[hostSpec.vsname].tag_suffix;
    const url = langInfo[hostSpec.vsname].syntax_url;

    const embeddedCommentPatterns = embeddedSpecs.map((lang) => {
        return {
            'comment': `${lang.name} formatted template strings`,
            'begin': String.raw`(?x)
(/\*(?i:${lang.id_choice_re})\*/)
\s*
([_\$[:alpha:]][_\$[:alnum:]]*)?
(\`)`,
            'contentName': `meta.embedded.block.${lang.vsname}.${hostSpec.vsname} ${lang.root_scope}`,
            'end': '`',
            'beginCaptures': {
                '1': { 'patterns': [{ 'include': `source.${suffix}#comment` }] },
                '2': { 'name': `entity.name.function.tagged-template.${suffix}` },
                '3': { 'name': `string.template.${suffix} punctuation.definition.string.template.begin.${suffix}` },
            },
            'endCaptures': {
                '0': { 'name': `string.template.${suffix} punctuation.definition.string.template.end.${suffix}` },
            },
            'patterns': [
                { 'include': '#template-substitution-element' },
                { 'include': '#string-character-escape' },
                { 'include': `${lang.root_scope}` },
            ],
        };
    });

    // Build the patterns that match each embedded language, using
    // a tagged template. Implementation of the tag function is left
    // to the users. (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
    // Example: cpp`...`
    const embeddedTagPatterns = embeddedSpecs.map((lang) => {
        return {
            'comment': `${lang.name} formatted template strings`,
            'begin': String.raw`(?x)
(?i:${lang.id_choice_re})
(\`)`,
            'contentName': `meta.embedded.block.${lang.vsname}.${hostSpec.vsname} ${lang.root_scope}`,
            'beginCaptures': {
                '1': { 'name': `entity.name.function.tagged-template.${suffix}` },
                '2': { 'name': `string.template.${suffix} punctuation.definition.string.template.begin.${suffix}` },
            },
            'end': '`',
            'endCaptures': {
                '0': { 'name': `string.template.${suffix} punctuation.definition.string.template.end.${suffix}` },
            },
            'patterns': [
                // TODO: Can we include something here to make javascript
                // tempalte substitutions get highlighted in javascript?
                // For example the string in ${} should be JS highlighted:
                //    const py_string = /*py*/ `
                //    print("Hello ${(await fetch('http://example.com')).body.json();}")
                //    `;
                { 'include': `${lang.root_scope}` },
            ],
        };
    });

    // Build the overall grammar injection file, and include the
    // patterns from above
    return {
        '$schema': 'https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json',
        'comment': `This file has been automatically generated by syntax_assembler.js
DO NOT HAND EDIT IT - changes will be lost.`,
        'injectionSelector': `L:source.${suffix} -string -comment`,
        'scopeName': `${hostSpec.embedded_scope}`,
        'patterns': [
            { 'include': '#template-string-with-tag' },
            { 'include': '#template-string-with-preceeding-comment' },
        ],
        'repository': {
            'template-string-with-preceeding-comment': {
                'comment': `These patterns all match Typescript/JavaScript template strings and select one language.` +
                    `The syntax is injected into ${url}`,
                'patterns': embeddedCommentPatterns,
            },
            'template-string-with-tag': {
                'comment': `These patterns all match Typescript/JavaScript template strings and select one language.` +
                    `The syntax is injected into ${url}`,
                'patterns': embeddedTagPatterns,
            },
        },
    };
}
